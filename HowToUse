
How to use Exana for analyzing an execution of applications
-------------------------------------------------------------

Examples are in the 'Sample.Exana' directory.  Please move to
'Sample.Exana' directory.  

     % cd Sample.Exana

Then, you can find two directories: 'LoopAndCall' and 'Himeno'.  Using
these sample code, you can have experiences of application profiling.

     % cd LoopAndCall
     % ./SampleMain
     % Exana -- ./SampleMain
     % less <mmdd.pid>/exana.out
     % vizLcctm <mmdd.pid>/lcct.dat &

     Note: Please set up your environment with 'setupExana' script.
     	   Further information is in the INSTALL file of ExanaPkg.

After an analysis, Exana generates the <mmdd.pid> directory which contains analysis result files.  In that directory, there are three files, exana.out,
static.out, lcct.dat (or lcctm.dat).

* exana.out represents dynamic profiling results.
* static.out represents static analysis results.
* lcct.dat (or lcctm.dat) is a binary file that represent loop call
  context tree respresentation of the executed binary.  When you use
  -mode LCCT+M, then lcctm.dat is generated.  The LCCT+M contains
  loop-level data dependence information.

Also, You can visualize lcct.dat (or lcctm.dat) using the following
command, vizLcctm.  Then, you can visualize the LCCT graph with nodes
that are greater than threshold.  Here, the function 'main' becomes a
root node of the tree.  Selecting the checkbox at the top of window,
we can observe statistics obtained during the analysis interactively.
Also, you can specify thresholds for visualing a particular region by
putting the value and push the submit bottom.  TopN means that we try
to visualize the top N nodes and their parents.

Based on LCCT graph, you can observe dynamic loop structures in the
actual execution, and locations of them in the actual source code.  To
obtain information of source code locations, you need to specify debug
option '-g' when you compile your executable code.

If you would like to analyze data dependences among loops and calls,
then please specify an option for LCCT+M analysis:

     % Exana -mode LCCT+M -- ./SampleMain
     % vizLcctm <mmdd.pid>/lcctm.dat&

If you would like to obtain actual memory traces during the execution,
then please specify an option for memtrace, and the result is
outputted to "memTrace.out.X" file.  

     % Exana -memtrace 1 -- ./SampleMain
     % less  <mmdd.pid>/memTrace.out.1
         Here, the memory trace result is written to automatically 
	 roteted files starting from 1.  

      The basic format of the memTrace (-memtrace 1) is 
          [R]ead/[W]rite_size@MemInstAddress, memoryAddress

      If you specify -memtrace 2 option; 
      	  cycle count, rtnName/loopID + basic format 


If you would like to analyze memory access patterns for each instructions,
then please specify an option for MemPat analysis:

     % Exana -mempat 1 -- ./SampleMain
     % cd <mmdd.pid>
         Here, the memory access patterns are outputted to mempat.dat
     % viewMempat 
         Then, you can view the memory access patterns for each instructions
         in a text format.

Now, you can try Himeno Benchmark to evaluate feasibility for parallel
programs.

      % cd Himeno
      % export OMP_NUM_THREADS=1
      % ./bmt S
      % Exana -- ./bmt S
      % vizLcctm mmdd.pid/lcctm.dat &
      % Exana -mode LCCT+M -- ./bmt S
      % vizLcctm mmdd.pid/lcctm.dat &

If you would like to execute a multithread application, currently we
only support analyzing LCCT for the primary thread, which is running
at the begining of the main function before other threads are forked.

      % export OMP_NUM_THREADS=4
      % ./bmt S
      % Exana -- ./bmt S
      % vizLcctm mmdd.pid/lcctm.dat &

If you would like to execute an MPI application, please specify mpirun
before Exana command.  Then, you can obtain LCCTs for each process.

      % export OMP_NUM_THREADS=1
      % mpirun -np 4 ./bmt S
      % mpirun -np 4 Exana -- ./bmt S
      % vizLcctm mmdd.pid/lcct.dat &



====================================================================
Format of each file or representation:

(1) memTrace.out 

It contains all of memory access traces among the specified
region.  The detail file format is as follows: Each memory access is
represented in one line such as "R8@401812 7fffe81bd5c8". The first
element 'R8@401812' means 8 byte read memory access performed by
memory access instruction located at 0x401812 in the executed binary
code.  The second element '7fffe81bd5c8' means the memory address of
accessed by the memory instruction.

In the memTrace.out file, other lines than actual memory access
information begin with the prefix "##".  At the top of each iteration,
the trip count of the loop iteration is presented like: "## loopID =
32 apr = 1 tripCnt 1 range=[1,2]"

The working data set size of the region appears in the
'prof.out.<pid>'.  If you would like check only the information without
memory trace file, please specify the region with '-memtrace 0'
option, then you can obtain much faster and analyze the larger region.


(2) prof.out.<pid>
It includes
  Total number of dynamic instances in LCCT+M
  accumulated instruction counts (accBaseInst, accFpInst, accVecInst) (*)
  working data set size (touch-page)
  working data set size (read, write or either, memory operation base)
  Cycles obtained by RDTSC 

 (*) Here, we divide instruction class as follows:
     FpInst: XED_EXTENSION_X87 
     VecInst: XED_EXTENSION_SSE, XED_EXTENSION_SSE2, XED_EXTENSION_SSE3, 
              XED_EXTENSION_SSE4,XED_EXTENSION_SSE4A,
              XED_EXTENSION_SSSE3,XED_EXTENSION_AVX, XED_EXTENSION_AVX2,
              XED_EXTENSION_AVX2GATHER
     BaseInst: Others

     based on "enum xed_extension_enum_t" of XED
     http://software.intel.com/sites/landingpage/pintool/docs/53271/Xed/html/main.html#API_REF


(3) <bin>_<mmdd.pid>.dot

You can visualize dot file using graphviz.  The specification of dot
file is as follows:

http://www.graphviz.org/


(4)  LCCT or LCCT+M representation

Here, the circles represent loops, the boxes represent procedure
calls.  Dynamic control flows of L-CCT are represented in solid
(black) lines.  So, an outer loop become a parent node and an inner
loop become a child node of this graph.  Also, we can find the # of
appearances of each node.  The average # of loop iterations is
outputted if the node is a loop.  

In each node, we can see the time cost for executing the node.  After
the percentage of the total cycles accumulated over all of its
successors, the percentage of the cycles executed in the node itself
is represented inside the parenthesis.  In the dot file, only the
nodes that exceed summary_threshold appeared.  In the prof.out.<pid>
file, all of appeared nodes are recorded.

In LCCT+M representation, in addition to loop structures, we can see
the dependencies among them.  Here, dynamic data dependencies are
represented in arrows with dashed lines.  Here, an arrowed dash line
(blue color) indicates data dependencies between these two regions.
An arrowed dash line (orange color) indicates data dependencies among
different appearances of a loop.  The Average distances of them are
represented in D_itr and D_apr.

There are three possible data dependencies in the view of a dynamic
execution context: across regions, between appearances of a loop, and
between iterations of a loop.  Using the LCCT+M representation, we can
represent all of three dependencies.


