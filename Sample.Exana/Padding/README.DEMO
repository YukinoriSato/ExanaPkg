
How to use Exana for performance tuning of memory layout
-------------------------------------------------------------

Now you are in the '$(EXANA_DIR)/Sample.Exana/Padding' directory.
Using sample code in this directory, you can have experiences of
application profiling and its feed-back to the source code.

     % make
     % export OMP_NUM_THREADS=1
     % ./bmt S

     After executing the code, you should check the performance score
     [MFLOPS measured] of native execution.

     For example) MFLOPS measured : 2067.196551

     Next, we analyze the application using Exana
     % Exana -mode traceConsol -- ./bmt S
     % cd <mmdd.pid>
     % traceConsol -j -b ../bmt > exanaview.json
     % ExanaView &

     Now you run ExanaView, which is Exana's result and the
     corresponding source location viewer.

     Please select a generated json file.  
     	    File -> Open JSON file

     Then, you can find cache statistics listed by descending order of
     Est.lat (estimated latency).  You can find memory object that the
     instruction accessed and where it is created.  Also, if you
     attach a debug option (-g) at build time, you can find the
     location of source code of the instruction.  If you click the row
     of the statistics, the correspondig source code is highlighted at
     the top of the window.

     In this example, it is observed that most of L1 cache miss is due
     to conflict miss and memory objects are created from main:124 to
     main:129.  In order to avoid the conflict miss, we perform
     padding and insert an extra spece into each dimension.


      main:107 
      Before:
      ////// Fix data layout  ///////
      mimax= imax;
      mjmax= jmax;
      mkmax= kmax;
      ///////////////////////////

      After:
      ////// Fix data layout  ///////
      mimax= imax+1;
      mjmax= jmax+1;
      mkmax= kmax+1;
      ///////////////////////////

      We can edit source code on ExanaView.  After save the file from
      menu bar (File -> Save source code file), build binary code again.

     % make
     % ./bmt S

     After executing the code, you should check the performance score
     [MFLOPS measured] of native execution.

     For example) MFLOPS measured : 2391.494011

     Now, you can find padding contributes to performance gain.

     If we profile the modified code again and check the occurances of
     cache conflict using ExanaView, it is observed these are
     dramatically reduced.

     % Exana -mode traceConsol -- ./bmt S
     % cd <mmdd.pid>
     % traceConsol -j -b ../bmt > exanaview.json
     % ExanaView &
